diff --git a/lib/scope/index.js b/lib/scope/index.js
index 38d5100d23b3f040d29942f2ddda78fa4278be10..ba07db5b05ecfbb5cb5ff92f506ab95d234f0f94 100644
--- a/lib/scope/index.js
+++ b/lib/scope/index.js
@@ -1,13 +1,12 @@
 "use strict";
 
 Object.defineProperty(exports, "__esModule", {
-  value: true
+  value: true,
 });
 exports.default = void 0;
 var _renamer = require("./lib/renamer.js");
 var _index = require("../index.js");
 var _binding = require("./binding.js");
-var _globals = require("globals");
 var _t = require("@babel/types");
 var t = _t;
 var _cache = require("../cache.js");
@@ -58,23 +57,41 @@ const {
   isMetaProperty,
   isPrivateName,
   isExportDeclaration,
-  buildUndefinedNode
+  buildUndefinedNode,
 } = _t;
 function gatherNodeParts(node, parts) {
   switch (node == null ? void 0 : node.type) {
     default:
       if (isImportDeclaration(node) || isExportDeclaration(node)) {
         var _node$specifiers;
-        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {
+        if (
+          (isExportAllDeclaration(node) ||
+            isExportNamedDeclaration(node) ||
+            isImportDeclaration(node)) &&
+          node.source
+        ) {
           gatherNodeParts(node.source, parts);
-        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && (_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
+        } else if (
+          (isExportNamedDeclaration(node) || isImportDeclaration(node)) &&
+          (_node$specifiers = node.specifiers) != null &&
+          _node$specifiers.length
+        ) {
           for (const e of node.specifiers) gatherNodeParts(e, parts);
-        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {
+        } else if (
+          (isExportDefaultDeclaration(node) ||
+            isExportNamedDeclaration(node)) &&
+          node.declaration
+        ) {
           gatherNodeParts(node.declaration, parts);
         }
       } else if (isModuleSpecifier(node)) {
         gatherNodeParts(node.local, parts);
-      } else if (isLiteral(node) && !isNullLiteral(node) && !isRegExpLiteral(node) && !isTemplateLiteral(node)) {
+      } else if (
+        isLiteral(node) &&
+        !isNullLiteral(node) &&
+        !isRegExpLiteral(node) &&
+        !isTemplateLiteral(node)
+      ) {
         parts.push(node.value);
       }
       break;
@@ -179,9 +196,7 @@ const collectorVisitor = {
   ForStatement(path) {
     const declar = path.get("init");
     if (declar.isVar()) {
-      const {
-        scope
-      } = path;
+      const { scope } = path;
       const parentScope = scope.getFunctionParent() || scope.getProgramParent();
       parentScope.registerBinding("var", declar);
     }
@@ -190,7 +205,8 @@ const collectorVisitor = {
     if (path.isBlockScoped()) return;
     if (path.isImportDeclaration()) return;
     if (path.isExportDeclaration()) return;
-    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
+    const parent =
+      path.scope.getFunctionParent() || path.scope.getProgramParent();
     parent.registerDeclaration(path);
   },
   ImportDeclaration(path) {
@@ -205,19 +221,14 @@ const collectorVisitor = {
     if (left.isPattern() || left.isIdentifier()) {
       state.constantViolations.push(path);
     } else if (left.isVar()) {
-      const {
-        scope
-      } = path;
+      const { scope } = path;
       const parentScope = scope.getFunctionParent() || scope.getProgramParent();
       parentScope.registerBinding("var", left);
     }
   },
   ExportDeclaration: {
     exit(path) {
-      const {
-        node,
-        scope
-      } = path;
+      const { node, scope } = path;
       if (isExportAllDeclaration(node)) return;
       const declar = node.declaration;
       if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
@@ -233,7 +244,7 @@ const collectorVisitor = {
           }
         }
       }
-    }
+    },
   },
   LabeledStatement(path) {
     path.scope.getBlockParent().registerDeclaration(path);
@@ -268,7 +279,11 @@ const collectorVisitor = {
     for (const param of params) {
       path.scope.registerBinding("param", param);
     }
-    if (path.isFunctionExpression() && path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING]) {
+    if (
+      path.isFunctionExpression() &&
+      path.has("id") &&
+      !path.get("id").node[NOT_LOCAL_BINDING]
+    ) {
       path.scope.registerBinding("local", path.get("id"), path);
     }
   },
@@ -279,7 +294,7 @@ const collectorVisitor = {
   },
   TSTypeAnnotation(path) {
     path.skip();
-  }
+  },
 };
 let uid = 0;
 class Scope {
@@ -295,9 +310,7 @@ class Scope {
     this.uids = void 0;
     this.data = void 0;
     this.crawling = void 0;
-    const {
-      node
-    } = path;
+    const { node } = path;
     const cached = _cache.scope.get(node);
     if ((cached == null ? void 0 : cached.path) === path) {
       return cached;
@@ -334,7 +347,7 @@ class Scope {
   generateDeclaredUidIdentifier(name) {
     const id = this.generateUidIdentifier(name);
     this.push({
-      id
+      id,
     });
     return cloneNode(id);
   }
@@ -342,13 +355,20 @@ class Scope {
     return identifier(this.generateUid(name));
   }
   generateUid(name = "temp") {
-    name = toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
+    name = toIdentifier(name)
+      .replace(/^_+/, "")
+      .replace(/[0-9]+$/g, "");
     let uid;
     let i = 1;
     do {
       uid = this._generateUid(name, i);
       i++;
-    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));
+    } while (
+      this.hasLabel(uid) ||
+      this.hasBinding(uid) ||
+      this.hasGlobal(uid) ||
+      this.hasReference(uid)
+    );
     const program = this.getProgramParent();
     program.references[uid] = true;
     program.uids[uid] = true;
@@ -390,7 +410,7 @@ class Scope {
       const id = this.generateUidIdentifierBasedOnNode(node);
       if (!dontPush) {
         this.push({
-          id
+          id,
         });
         return cloneNode(id);
       }
@@ -400,9 +420,18 @@ class Scope {
   checkBlockScopedCollisions(local, kind, name, id) {
     if (kind === "param") return;
     if (local.kind === "local") return;
-    const duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";
+    const duplicate =
+      kind === "let" ||
+      local.kind === "let" ||
+      local.kind === "const" ||
+      local.kind === "module" ||
+      (local.kind === "param" && kind === "const");
     if (duplicate) {
-      throw this.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
+      throw this.hub.buildError(
+        id,
+        `Duplicate declaration "${name}"`,
+        TypeError
+      );
     }
   }
   rename(oldName, newName) {
@@ -433,26 +462,41 @@ class Scope {
           constant: binding.constant,
           references: binding.references,
           violations: binding.constantViolations.length,
-          kind: binding.kind
+          kind: binding.kind,
         });
       }
-    } while (scope = scope.parent);
+    } while ((scope = scope.parent));
     console.log(sep);
   }
   toArray(node, i, arrayLikeIsIterable) {
     if (isIdentifier(node)) {
       const binding = this.getBinding(node.name);
-      if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
+      if (
+        binding != null &&
+        binding.constant &&
+        binding.path.isGenericType("Array")
+      ) {
         return node;
       }
     }
     if (isArrayExpression(node)) {
       return node;
     }
-    if (isIdentifier(node, {
-      name: "arguments"
-    })) {
-      return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"), identifier("prototype")), identifier("slice")), identifier("call")), [node]);
+    if (
+      isIdentifier(node, {
+        name: "arguments",
+      })
+    ) {
+      return callExpression(
+        memberExpression(
+          memberExpression(
+            memberExpression(identifier("Array"), identifier("prototype")),
+            identifier("slice")
+          ),
+          identifier("call")
+        ),
+        [node]
+      );
     }
     let helperName;
     const args = [node];
@@ -486,25 +530,35 @@ class Scope {
       this.registerBinding("hoisted", path.get("id"), path);
     } else if (path.isVariableDeclaration()) {
       const declarations = path.get("declarations");
-      const {
-        kind
-      } = path.node;
+      const { kind } = path.node;
       for (const declar of declarations) {
-        this.registerBinding(kind === "using" || kind === "await using" ? "const" : kind, declar);
+        this.registerBinding(
+          kind === "using" || kind === "await using" ? "const" : kind,
+          declar
+        );
       }
     } else if (path.isClassDeclaration()) {
       if (path.node.declare) return;
       this.registerBinding("let", path);
     } else if (path.isImportDeclaration()) {
-      const isTypeDeclaration = path.node.importKind === "type" || path.node.importKind === "typeof";
+      const isTypeDeclaration =
+        path.node.importKind === "type" || path.node.importKind === "typeof";
       const specifiers = path.get("specifiers");
       for (const specifier of specifiers) {
-        const isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === "type" || specifier.node.importKind === "typeof");
+        const isTypeSpecifier =
+          isTypeDeclaration ||
+          (specifier.isImportSpecifier() &&
+            (specifier.node.importKind === "type" ||
+              specifier.node.importKind === "typeof"));
         this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);
       }
     } else if (path.isExportDeclaration()) {
       const declar = path.get("declaration");
-      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
+      if (
+        declar.isClassDeclaration() ||
+        declar.isFunctionDeclaration() ||
+        declar.isVariableDeclaration()
+      ) {
         this.registerDeclaration(declar);
       }
     } else {
@@ -518,7 +572,8 @@ class Scope {
     const ids = path.getBindingIdentifiers();
     for (const name of Object.keys(ids)) {
       var _this$getBinding;
-      (_this$getBinding = this.getBinding(name)) == null || _this$getBinding.reassign(path);
+      (_this$getBinding = this.getBinding(name)) == null ||
+        _this$getBinding.reassign(path);
     }
   }
   registerBinding(kind, path, bindingPath = path) {
@@ -547,7 +602,7 @@ class Scope {
             identifier: id,
             scope: this,
             path: bindingPath,
-            kind: kind
+            kind: kind,
           });
         }
       }
@@ -560,14 +615,14 @@ class Scope {
     let scope = this;
     do {
       if (scope.uids[name]) return true;
-    } while (scope = scope.parent);
+    } while ((scope = scope.parent));
     return false;
   }
   hasGlobal(name) {
     let scope = this;
     do {
       if (scope.globals[name]) return true;
-    } while (scope = scope.parent);
+    } while ((scope = scope.parent));
     return false;
   }
   hasReference(name) {
@@ -579,14 +634,23 @@ class Scope {
       if (!binding) return false;
       if (constantsOnly) return binding.constant;
       return true;
-    } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {
+    } else if (
+      isThisExpression(node) ||
+      isMetaProperty(node) ||
+      isTopicReference(node) ||
+      isPrivateName(node)
+    ) {
       return true;
     } else if (isClass(node)) {
       var _node$decorators;
       if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
         return false;
       }
-      if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {
+      if (
+        ((_node$decorators = node.decorators) == null
+          ? void 0
+          : _node$decorators.length) > 0
+      ) {
         return false;
       }
       return this.isPure(node.body, constantsOnly);
@@ -596,7 +660,10 @@ class Scope {
       }
       return true;
     } else if (isBinary(node)) {
-      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
+      return (
+        this.isPure(node.left, constantsOnly) &&
+        this.isPure(node.right, constantsOnly)
+      );
     } else if (isArrayExpression(node) || isTupleExpression(node)) {
       for (const elem of node.elements) {
         if (elem !== null && !this.isPure(elem, constantsOnly)) return false;
@@ -610,14 +677,22 @@ class Scope {
     } else if (isMethod(node)) {
       var _node$decorators2;
       if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
-      if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {
+      if (
+        ((_node$decorators2 = node.decorators) == null
+          ? void 0
+          : _node$decorators2.length) > 0
+      ) {
         return false;
       }
       return true;
     } else if (isProperty(node)) {
       var _node$decorators3;
       if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
-      if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {
+      if (
+        ((_node$decorators3 = node.decorators) == null
+          ? void 0
+          : _node$decorators3.length) > 0
+      ) {
         return false;
       }
       if (isObjectProperty(node) || node.static) {
@@ -634,37 +709,53 @@ class Scope {
       }
       return true;
     } else if (isTaggedTemplateExpression(node)) {
-      return matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", {
-        noGlobals: true
-      }) && this.isPure(node.quasi, constantsOnly);
+      return (
+        matchesPattern(node.tag, "String.raw") &&
+        !this.hasBinding("String", {
+          noGlobals: true,
+        }) &&
+        this.isPure(node.quasi, constantsOnly)
+      );
     } else if (isMemberExpression(node)) {
-      return !node.computed && isIdentifier(node.object) && node.object.name === "Symbol" && isIdentifier(node.property) && node.property.name !== "for" && !this.hasBinding("Symbol", {
-        noGlobals: true
-      });
+      return (
+        !node.computed &&
+        isIdentifier(node.object) &&
+        node.object.name === "Symbol" &&
+        isIdentifier(node.property) &&
+        node.property.name !== "for" &&
+        !this.hasBinding("Symbol", {
+          noGlobals: true,
+        })
+      );
     } else if (isCallExpression(node)) {
-      return matchesPattern(node.callee, "Symbol.for") && !this.hasBinding("Symbol", {
-        noGlobals: true
-      }) && node.arguments.length === 1 && t.isStringLiteral(node.arguments[0]);
+      return (
+        matchesPattern(node.callee, "Symbol.for") &&
+        !this.hasBinding("Symbol", {
+          noGlobals: true,
+        }) &&
+        node.arguments.length === 1 &&
+        t.isStringLiteral(node.arguments[0])
+      );
     } else {
       return isPureish(node);
     }
   }
   setData(key, val) {
-    return this.data[key] = val;
+    return (this.data[key] = val);
   }
   getData(key) {
     let scope = this;
     do {
       const data = scope.data[key];
       if (data != null) return data;
-    } while (scope = scope.parent);
+    } while ((scope = scope.parent));
   }
   removeData(key) {
     let scope = this;
     do {
       const data = scope.data[key];
       if (data != null) scope.data[key] = null;
-    } while (scope = scope.parent);
+    } while ((scope = scope.parent));
   }
   init() {
     if (!this.inited) {
@@ -684,10 +775,13 @@ class Scope {
     const state = {
       references: [],
       constantViolations: [],
-      assignments: []
+      assignments: [],
     };
     this.crawling = true;
-    if (path.type !== "Program" && (0, _visitors.isExplodedVisitor)(collectorVisitor)) {
+    if (
+      path.type !== "Program" &&
+      (0, _visitors.isExplodedVisitor)(collectorVisitor)
+    ) {
       for (const visit of collectorVisitor.enter) {
         visit.call(state, path, state);
       }
@@ -730,17 +824,24 @@ class Scope {
     if (path.isSwitchStatement()) {
       path = (this.getFunctionParent() || this.getProgramParent()).path;
     }
-    const {
-      init,
-      unique,
-      kind = "var",
-      id
-    } = opts;
-    if (!init && !unique && (kind === "var" || kind === "let") && path.isFunction() && !path.node.name && isCallExpression(path.parent, {
-      callee: path.node
-    }) && path.parent.arguments.length <= path.node.params.length && isIdentifier(id)) {
+    const { init, unique, kind = "var", id } = opts;
+    if (
+      !init &&
+      !unique &&
+      (kind === "var" || kind === "let") &&
+      path.isFunction() &&
+      !path.node.name &&
+      isCallExpression(path.parent, {
+        callee: path.node,
+      }) &&
+      path.parent.arguments.length <= path.node.params.length &&
+      isIdentifier(id)
+    ) {
       path.pushContainer("params", id);
-      path.scope.registerBinding("param", path.get("params")[path.node.params.length - 1]);
+      path.scope.registerBinding(
+        "param",
+        path.get("params")[path.node.params.length - 1]
+      );
       return;
     }
     if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
@@ -766,7 +867,7 @@ class Scope {
       if (scope.path.isProgram()) {
         return scope;
       }
-    } while (scope = scope.parent);
+    } while ((scope = scope.parent));
     throw new Error("Couldn't find a Program");
   }
   getFunctionParent() {
@@ -775,7 +876,7 @@ class Scope {
       if (scope.path.isFunctionParent()) {
         return scope;
       }
-    } while (scope = scope.parent);
+    } while ((scope = scope.parent));
     return null;
   }
   getBlockParent() {
@@ -784,8 +885,10 @@ class Scope {
       if (scope.path.isBlockParent()) {
         return scope;
       }
-    } while (scope = scope.parent);
-    throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
+    } while ((scope = scope.parent));
+    throw new Error(
+      "We couldn't find a BlockStatement, For, Switch, Function, Loop or Program..."
+    );
   }
   getPatternParent() {
     let scope = this;
@@ -793,8 +896,10 @@ class Scope {
       if (!scope.path.isPattern()) {
         return scope.getBlockParent();
       }
-    } while (scope = scope.parent.parent);
-    throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
+    } while ((scope = scope.parent.parent));
+    throw new Error(
+      "We couldn't find a BlockStatement, For, Switch, Function, Loop or Program..."
+    );
   }
   getAllBindings() {
     const ids = Object.create(null);
@@ -833,21 +938,34 @@ class Scope {
       const binding = scope.getOwnBinding(name);
       if (binding) {
         var _previousPath;
-        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param" && binding.kind !== "local") {} else {
+        if (
+          (_previousPath = previousPath) != null &&
+          _previousPath.isPattern() &&
+          binding.kind !== "param" &&
+          binding.kind !== "local"
+        ) {
+        } else {
           return binding;
         }
-      } else if (!binding && name === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
+      } else if (
+        !binding &&
+        name === "arguments" &&
+        scope.path.isFunction() &&
+        !scope.path.isArrowFunctionExpression()
+      ) {
         break;
       }
       previousPath = scope.path;
-    } while (scope = scope.parent);
+    } while ((scope = scope.parent));
   }
   getOwnBinding(name) {
     return this.bindings[name];
   }
   getBindingIdentifier(name) {
     var _this$getBinding2;
-    return (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.identifier;
+    return (_this$getBinding2 = this.getBinding(name)) == null
+      ? void 0
+      : _this$getBinding2.identifier;
   }
   getOwnBindingIdentifier(name) {
     const binding = this.bindings[name];
@@ -861,19 +979,31 @@ class Scope {
     if (!name) return false;
     if (this.hasOwnBinding(name)) return true;
     {
-      if (typeof opts === "boolean") opts = {
-        noGlobals: opts
-      };
+      if (typeof opts === "boolean")
+        opts = {
+          noGlobals: opts,
+        };
     }
     if (this.parentHasBinding(name, opts)) return true;
-    if (!((_opts = opts) != null && _opts.noUids) && this.hasUid(name)) return true;
-    if (!((_opts2 = opts) != null && _opts2.noGlobals) && Scope.globals.includes(name)) return true;
-    if (!((_opts3 = opts) != null && _opts3.noGlobals) && Scope.contextVariables.includes(name)) return true;
+    if (!((_opts = opts) != null && _opts.noUids) && this.hasUid(name))
+      return true;
+    if (
+      !((_opts2 = opts) != null && _opts2.noGlobals) &&
+      Scope.globals.includes(name)
+    )
+      return true;
+    if (
+      !((_opts3 = opts) != null && _opts3.noGlobals) &&
+      Scope.contextVariables.includes(name)
+    )
+      return true;
     return false;
   }
   parentHasBinding(name, opts) {
     var _this$parent;
-    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, opts);
+    return (_this$parent = this.parent) == null
+      ? void 0
+      : _this$parent.hasBinding(name, opts);
   }
   moveBindingTo(name, scope) {
     const info = this.getBinding(name);
@@ -888,17 +1018,82 @@ class Scope {
   }
   removeBinding(name) {
     var _this$getBinding3;
-    (_this$getBinding3 = this.getBinding(name)) == null || _this$getBinding3.scope.removeOwnBinding(name);
+    (_this$getBinding3 = this.getBinding(name)) == null ||
+      _this$getBinding3.scope.removeOwnBinding(name);
     let scope = this;
     do {
       if (scope.uids[name]) {
         scope.uids[name] = false;
       }
-    } while (scope = scope.parent);
+    } while ((scope = scope.parent));
   }
 }
 exports.default = Scope;
-Scope.globals = Object.keys(_globals.builtin);
+Scope.globals = Object.keys({
+  Array: false,
+  ArrayBuffer: false,
+  Atomics: false,
+  BigInt: false,
+  BigInt64Array: false,
+  BigUint64Array: false,
+  Boolean: false,
+  constructor: false,
+  DataView: false,
+  Date: false,
+  decodeURI: false,
+  decodeURIComponent: false,
+  encodeURI: false,
+  encodeURIComponent: false,
+  Error: false,
+  escape: false,
+  eval: false,
+  EvalError: false,
+  Float32Array: false,
+  Float64Array: false,
+  Function: false,
+  globalThis: false,
+  hasOwnProperty: false,
+  Infinity: false,
+  Int16Array: false,
+  Int32Array: false,
+  Int8Array: false,
+  isFinite: false,
+  isNaN: false,
+  isPrototypeOf: false,
+  JSON: false,
+  Map: false,
+  Math: false,
+  NaN: false,
+  Number: false,
+  Object: false,
+  parseFloat: false,
+  parseInt: false,
+  Promise: false,
+  propertyIsEnumerable: false,
+  Proxy: false,
+  RangeError: false,
+  ReferenceError: false,
+  Reflect: false,
+  RegExp: false,
+  Set: false,
+  SharedArrayBuffer: false,
+  String: false,
+  Symbol: false,
+  SyntaxError: false,
+  toLocaleString: false,
+  toString: false,
+  TypeError: false,
+  Uint16Array: false,
+  Uint32Array: false,
+  Uint8Array: false,
+  Uint8ClampedArray: false,
+  undefined: false,
+  unescape: false,
+  URIError: false,
+  valueOf: false,
+  WeakMap: false,
+  WeakSet: false,
+});
 Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
 
 //# sourceMappingURL=index.js.map
